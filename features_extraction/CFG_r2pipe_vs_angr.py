#!/usr/bin/env python3

import r2pipe
import networkx as nx
import angr
import numpy as np
import time

def generate_cfg(binary_path, mode):
    """
    Load the binary with angr, locate 'main' (or fallback to entry),
    then generate either CFGEmulated or CFGFast.
    """
    proj = angr.Project(binary_path, auto_load_libs=False)

    # Locate 'main', else entry
    main_symbol = proj.loader.main_object.get_symbol("main")
    if main_symbol is None:
        print("[*] 'main' not found. Falling back to the entry point.")
        main_addr = proj.loader.main_object.entry
    else:
        main_addr = main_symbol.rebased_addr

    if mode == "emulated":
        print("  -> Using CFGEmulated analysis...")
        start_state = proj.factory.blank_state(addr=main_addr)
        cfg = proj.analyses.CFGEmulated(
            starts=[main_addr],
            initial_state=start_state,
            fail_fast=True
        )
    else:
        print("  -> Using CFGFast analysis...")
        cfg = proj.analyses.CFGFast()

    return cfg

def extract_cfg_features(nx_graph):
    """
    Extract numerical features from a Control Flow Graph (CFG) in NetworkX form.
    We keep avg_out_degree, max_in_degree, max_out_degree, etc.
    """
    print("[extract_cfg_features] Starting feature extraction...")
    features = {}

    print("[extract_cfg_features] Counting nodes/edges...")
    num_nodes = nx_graph.number_of_nodes()
    num_edges = nx_graph.number_of_edges()
    features['CFG_num_nodes'] = num_nodes
    features['CFG_num_edges'] = num_edges

    print("[extract_cfg_features] Calculating density...")
    features['CFG_density'] = nx.density(nx_graph)
    
    if num_nodes > 0:
        print("[extract_cfg_features] Calculating out_degree & in_degree stats...")
        out_degrees = [deg for _, deg in nx_graph.out_degree()]
        in_degrees  = [deg for _, deg in nx_graph.in_degree()]

        features['CFG_avg_out_degree'] = float(np.mean(out_degrees))
        features['CFG_max_out_degree'] = max(out_degrees)
        features['CFG_max_in_degree']  = max(in_degrees)
    else:
        print("[extract_cfg_features] No nodes in graph, setting degree stats to 0...")
        features['CFG_avg_out_degree'] = 0.0
        features['CFG_max_out_degree'] = 0
        features['CFG_max_in_degree']  = 0
    
    print("[extract_cfg_features] Counting weakly connected components...")
    num_components = nx.number_weakly_connected_components(nx_graph)
    features['CFG_connected_components'] = num_components
    
    print("[extract_cfg_features] Computing cyclomatic complexity...")
    features['CFG_cyclomatic_complexity'] = num_edges - num_nodes + num_components
    
    #print("[extract_cfg_features] Counting simple cycles (may be expensive for large graphs)...")
    #features['CFG_num_loops'] = sum(1 for _ in nx.simple_cycles(nx_graph))
    
    print("[extract_cfg_features] Calculating average path length (undirected approximation)...")
    try:
        features['CFG_avg_path_length'] = nx.average_shortest_path_length(nx_graph.to_undirected())
    except nx.NetworkXError:
        features['CFG_avg_path_length'] = -1
    
    print("[extract_cfg_features] Checking DAG longest path...")
    try:
        longest_path = nx.dag_longest_path(nx_graph)
        features['CFG_longest_path_length'] = len(longest_path) - 1
    except nx.NetworkXUnfeasible:
        features['CFG_longest_path_length'] = -1
    
    print("[extract_cfg_features] Checking entry/exit points (in_degree=0 or out_degree=0)...")
    if num_nodes > 0:
        features['CFG_num_entry_points'] = sum(1 for n in nx_graph.nodes() if nx_graph.in_degree(n) == 0)
        features['CFG_num_exit_points']  = sum(1 for n in nx_graph.nodes() if nx_graph.out_degree(n) == 0)
    else:
        features['CFG_num_entry_points'] = 0
        features['CFG_num_exit_points']  = 0

    print("[extract_cfg_features] Done extracting features.")
    return features

def build_cfg_from_json(binary_path):
    """
    Build a single NetworkX DiGraph from the JSON CFG of all functions.
    Tries to handle 'edges' arrays and individual fields (jump, fail, switch).
    """

    r2 = r2pipe.open(binary_path)
    r2.cmd("e log.quiet=true")
    r2.cmd("e bin.relocs.apply=true")
    r2.cmd("aaa")  # Full analysis

    functions = r2.cmdj("aflj") or []
    print(f"Found {len(functions)} functions in {binary_path}")

    G = nx.DiGraph()

    for func in functions:
        func_addr = func["offset"]
        func_name = func["name"]
        
        # Get JSON-based CFG for this function
        func_cfg_list = r2.cmdj(f"agfj {func_addr}") or []
        if not func_cfg_list:
            continue
        
        # Usually a list with one item describing the function
        func_cfg = func_cfg_list[0]
        blocks = func_cfg.get("blocks", [])
        
        for block in blocks:
            block_addr = block["offset"]
            
            # Add a node for the block
            G.add_node(block_addr, func=func_name, size=block.get("size", 0))

            # 1) Prefer 'edges' if present
            edges_data = block.get("edges")
            if edges_data:
                print("EDGE!")
                for edge in edges_data:
                    dst = edge.get("addr")
                    if dst is not None:
                        etype = edge.get("type")  # e.g. "jmp", "cjmp", "call", "switch", ...
                        G.add_edge(block_addr, dst, type=etype)
                continue  # If 'edges' exist, we've already accounted for them, skip below.

            # 2) If no 'edges' array, look for 'jump' and 'fail' 
            if "jump" in block:
                G.add_edge(block_addr, block["jump"], type="jump")
            if "fail" in block:
                G.add_edge(block_addr, block["fail"], type="fail")

            # 3) Check for 'switch' if present
            #    Typically 'switch' has a 'cases' array and possibly 'defjump'.
            switch_info = block.get("switch")
            if switch_info:
                print("SWITCH!")
                # Add edges for each case
                for case in switch_info.get("cases", []):
                    case_addr = case.get("addr")
                    if case_addr:
                        G.add_edge(block_addr, case_addr, type="switch_case")

                # Add edge for default jump (if any)
                defjump = switch_info.get("defjump")
                if defjump:
                    G.add_edge(block_addr, defjump, type="switch_defjump")
    r2.quit()
    return G

binary_path="/bin/ls"

start_time = time.time()
G_r2 = build_cfg_from_json(binary_path)
end_time = time.time()
print("Time taken:", end_time - start_time)

print(extract_cfg_features(G_r2))

print("-----------------------------")

start_time = time.time()
G_agr = generate_cfg(binary_path, "aoo")
end_time = time.time()
print("Time taken:", end_time - start_time)
print(extract_cfg_features(G_agr.graph))
