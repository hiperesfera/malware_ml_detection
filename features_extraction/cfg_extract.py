#!/usr/bin/env python3

import argparse
import os
import angr
from angrutils import plot_cfg
import netlsd
from collections import Counter
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Generate a CFG from a binary (emulated or fast) and analyze it with NetLSD (heat & wave)."
    )
    parser.add_argument("binary_path", help="Path to the target binary")
    parser.add_argument(
        "-m", "--mode", choices=["emulated", "fast"], default="emulated",
        help="Analysis mode (emulated or fast). Default is 'emulated'."
    )
    parser.add_argument("--plot", action="store_true", help="If set, output a minimal CFG PNG (using angrutils).")
    return parser.parse_args()

def generate_cfg(binary_path, mode):
    print(f"[*] Loading binary: {binary_path}")
    proj = angr.Project(binary_path, auto_load_libs=False)

    main_symbol = proj.loader.main_object.get_symbol("main")
    if main_symbol is None:
        print("[*] 'main' not found. Falling back to entry point.")
        main_addr = proj.loader.main_object.entry
    else:
        main_addr = main_symbol.rebased_addr
    
    print(f"[*] Entry function address: {hex(main_addr)}")

    if mode == "emulated":
        print("[*] Using CFGEmulated analysis...")
        start_state = proj.factory.blank_state(addr=main_addr)
        cfg = proj.analyses.CFGEmulated(
            starts=[main_addr], initial_state=start_state, keep_state=True
        )
    else:
        print("[*] Using CFGFast analysis...")
        cfg = proj.analyses.CFGFast()

    print("[*] CFG analysis completed.")
    return cfg

def compute_netlsd_descriptors(cfg):
    print("[*] Computing NetLSD descriptors...")
    nx_graph = cfg.graph
    desc_heat = netlsd.heat(nx_graph)
    desc_wave = netlsd.wave(nx_graph)
    print(f"[*] Heat descriptor length: {len(desc_heat)}")
    print(f"[*] Wave descriptor length: {len(desc_wave)}")
    return desc_heat, desc_wave

def plot_minimal_cfg(cfg, binary_path, mode):
    base_name = os.path.splitext(os.path.basename(binary_path))[0]
    output_prefix = f"{base_name}_{mode}_minimal"
    print(f"[*] Generating minimal CFG -> {output_prefix}.png")
    plot_cfg(
        cfg, output_prefix, asminst=False, vexinst=False, debug_info=False,
        remove_imports=True, remove_path_terminator=True, format='png'
    )
    print(f"[*] Created {output_prefix}.png")

def compute_outdegree_distribution(cfg, max_degree_bin):
    print("[*] Computing out-degree distribution...")
    out_degs = [deg for _, deg in cfg.out_degree()]
    deg_count = Counter(out_degs)
    features = {f"outdeg_{d}": deg_count[d] for d in range(max_degree_bin + 1)}
    features["outdeg_greater"] = sum(count for degree, count in deg_count.items() if degree > max_degree_bin)
    print(f"[*] Out-degree distribution: {features}")
    return features

def extract_cfg_features(cfg):
    print("[*] Extracting CFG features...")
    features = {}
    num_nodes, num_edges = cfg.number_of_nodes(), cfg.number_of_edges()
    features.update({
        'num_nodes': num_nodes,
        'num_edges': num_edges,
        'density': nx.density(cfg) if num_nodes > 0 else 0.0
    })
    if num_nodes > 0:
        out_degrees = [deg for _, deg in cfg.out_degree()]
        features['avg_out_degree'] = np.mean(out_degrees)
        features['max_out_degree'] = max(out_degrees)
        features['max_in_degree'] = max(deg for _, deg in cfg.in_degree())
    else:
        features.update({'avg_out_degree': 0.0, 'max_out_degree': 0, 'max_in_degree': 0})
    
    num_components = nx.number_weakly_connected_components(cfg)
    features['connected_components'] = num_components
    
    features['cyclomatic_complexity'] = num_edges - num_nodes + num_components

    #features['num_loops'] = sum(1 for _ in nx.simple_cycles(nx_graph))
    
    try:
        features['avg_path_length'] = nx.average_shortest_path_length(cfg.to_undirected())
    except nx.NetworkXError:
        features['avg_path_length'] = -1
    
    try:
        longest_path = nx.dag_longest_path(cfg)
        features['longest_path_length'] = len(longest_path) - 1
    except nx.NetworkXUnfeasible:
        features['longest_path_length'] = -1
    
    if num_nodes > 0:
        features['num_entry_points'] = sum(1 for n in cfg.nodes() if cfg.in_degree(n) == 0)
        features['num_exit_points']  = sum(1 for n in cfg.nodes() if cfg.out_degree(n) == 0)
    else:
        features['num_entry_points'] = 0
        features['num_exit_points']  = 0
    
    print(f"[*] Extracted features: {features}")
    return features

def build_feature_vector(cfg, max_degree_bin):
    features = {**extract_cfg_features(cfg), **compute_outdegree_distribution(cfg, max_degree_bin)}
    print("[*] Final feature vector:", features)
    return features

def main():
    args = parse_arguments()
    print("[*] Starting CFG analysis...")
    cfg = generate_cfg(args.binary_path, args.mode)
    print("[*] Computing CFG feature vector...")
    build_feature_vector(cfg.graph, max_degree_bin=5)
    if args.plot:
        plot_minimal_cfg(cfg, args.binary_path, args.mode)
        nx.draw(cfg.graph, with_labels=True)
        plt.show()
    print("[*] Analysis completed.")

if __name__ == "__main__":
    main()
